# GenAI_Algorithm_lab1 ==> 二元搜尋樹的各種實作(heap sort)
- `提問詞`:請寫出二元搜尋樹的演算法
- `提問詞`:請計算二元搜尋樹演算法的時間複雜度
- `提問詞`:請用Python寫出二元搜尋樹的演算法
- `提問詞`:請用C寫出二元搜尋樹的演算法
- `提問詞`:請用C++寫出二元搜尋樹的演算法
- `提問詞`:請用JAVA寫出二元搜尋樹的演算法
- `提問詞`:請用Rust寫出二元搜尋樹的演算法
- `提問詞`:請用go寫出二元搜尋樹的演算法
- `提問詞`:請用C#寫出二元搜尋樹的演算法
- `提問詞`:請用Javascript#寫出二元搜尋樹的演算法
## 二元搜尋樹（Binary Search Tree, BST）
## 演算法複雜度
二元搜尋樹（Binary Search Tree，BST）是一種基礎性資料結構，用於構建更為抽象的資料結構，例如集合、多重集、關聯陣列等。它具有以下特點：

每個節點最多只能有兩個子節點：左子節點和右子節點。
左子節點的值小於等於父節點的值，右子節點的值大於父節點的值。
每個子樹都是一個二元搜尋樹。

搜尋時間複雜度取決於樹的平衡性。在平衡的情況下，搜尋、插入和刪除操作的平均時間複雜度為 O(logN)
，其中 N
 是樹中節點的數量。然而，如果樹不平衡，最壞情況下的時間複雜度可能達到 O(N)
。
總結時間複雜度：

平均情況下：

插入：O(logN)

刪除：O(logN)

搜尋：O(logN)



最壞情況下：

插入：O(N)

刪除：O(N)

搜尋：O(N)
